#lang racket
;;; Graph Search
;;; Dr. M. Douglas Williams

(provide define-ruleset
         define-rule
         graph-search
         graph-statistics)

;;; Rule Sets

(struct ruleset (name (rules #:mutable)))

;;; (define-ruleset name)
(define-syntax-rule (define-ruleset name)
  (define name (ruleset 'name '())))

;;; Rules

(struct rule (name ruleset precondition action))

;;; (applicable? rule state) -> boolean?
;;;   rule : rule?
;;;   state : any?
;;; Returns true if rule is applicable to state.
(define (applicable? rule state)
  ((rule-precondition rule) state))

;;; (action rule state) -> any/c
;;;   rule : rule?
;;;   state : any?
;;; Returns the state resulting from applying rule state.
(define (action rule state)
  ((rule-action rule) state))

;;; (define-rule ruleset (name arg ...)
;;;   precondition
;;; =>
;;;   action)
(define-syntax define-rule
  (syntax-rules (=>)
    ((define-rule ruleset (name arg ...)
       precondition
       =>
       action)
     (set-ruleset-rules!
      ruleset
      (append (ruleset-rules ruleset)
              (list (rule 'name
                          ruleset
                          (lambda (arg ...) precondition)
                          (lambda (arg ...) action))))))))

;;; State Space Graph

(define nodes (make-parameter (make-hash)))

(struct node (state
              (cost #:mutable)
              (value #:mutable)
              (status #:mutable)
              (parent #:mutable)
              (successors #:mutable)))

;;; (get-node state) -> node?
;;;   state : any?
;;; Returns the node for state. This returns a existing node for state if there
;;; is one, otherwise it creates a new node for the state.
(define (get-node state)
  (hash-ref!
   (nodes)
   state
   (lambda () (node state 0 0 #f #f '()))))

;;; (get-node-successors node ruleset) -> (listof node?)
;;;   node : node?
;;;   ruleset: ruleset?
;;; Returns the (unique) successor nodes of node using the rules in ruleset.
(define (get-node-successors node ruleset)
  (define state (node-state node))
  (for/fold ((successors '()))
            ((rule (in-list (ruleset-rules ruleset))))
    (cond ((applicable? rule state)
           (define successor (get-node (action rule state)))
           (cond ((memq successor successors)
                  successors)
                 (else
                  (append successors (list successor)))))
          (else
           successors))))

;;; (ancestor-states node) -> (listof any?)
;;;   node : node?
;;; Returns a list of the ancestor nodes of node in the search tree. When node is
;;; a goal node, this will be the states in the solution from the start node.
(define (ancestor-states node)
  (cond ((not node)
         '())
        (else
         (append (ancestor-states (node-parent node))
                 (list (node-state node))))))

;;; (graph-statistics) -> any/c
;;; Prints statistics about the state space graph.
(define (graph-statistics)
  (define n-nodes 0)
  (define n-closed 0)
  (for ((node (in-hash-values (nodes))))
    (set! n-nodes (+ n-nodes 1))
    (when (eq? (node-status node) 'closed)
      (set! n-closed (+ n-closed 1))))
  (printf "Total nodes generated : ~a~n" n-nodes)
  (printf "Nodes expanded (included the goal): ~a~n" n-closed))

;;; (graph-search ruleset initial-state goal?
;;;               #:deadend? deadend?
;;;               #:value value
;;;               #:merge-method merge-method) -> (or/c (listof any?) #f)
;;;   ruleset : ruleset?
;;;   initial-state : any?
;;;   goal? : (-> any? boolean?)
;;;   deadend? : (-> any? boolean?) = (lambda (state) #f)
;;;   value : (-> any? real? real?) = (lambda (state cost) cost)
;;;   merge-method : (one-of 'prepend 'append 'sort)
;;; Searchs the state space generated by ruleset from initial-state to a goal,
;;; which is defined by goal?
(define (graph-search ruleset initial-state goal?
                      #:deadend? (deadend? (lambda (state) #f))
                      #:value (value (lambda (state cost) cost))
                      #:merge-method (merge-method 'append))
  (define (check-new-path node successor)
    (define new-cost (+ (node-cost node) 1))
    (when (< new-cost (node-cost successor))
      (set-node-parent! successor node)
      (set-node-cost! successor new-cost)
      (set-node-value! successor (value (node-state successor) (node-cost successor)))
      (when (eq? (node-status successor) 'closed)
        (for ((successor-successor (in-list (node-successors successor))))
          (check-new-path successor successor-successor)))))
  (parameterize ((nodes (make-hash)))
    (define solution
      (let/ec exit
        ;; Add s as the only member of open.
        (define s (get-node initial-state))
        (define open (list s))
        (set-node-status! s 'open)
        (let loop ()
          (when (null? open)
            (exit #f))
          (begin
            (define n #f)
            (define successors '())
            (define new-nodes '())
            ;; Remove the first node from OPEN and assign it to n.
            (set!  n (car open))
            (set! open (cdr open))
            ;; Move node n to closed.
            (set-node-status! n 'closed)
            ;; If n is a goal node, exit with success.
            (when (goal? (node-state n))
              (exit (ancestor-states n)))
            ;; If n is a deadend node, don't expand it.
            (when (deadend? (node-state n))
              (loop))
            ;; Generate the successor nodes of n.
            (set! successors (get-node-successors n ruleset))
            (set-node-successors! n successors)
            ;; Process each successor.
            (for ((successor (in-list successors)))
              (cond ((not (node-status successor))
                     (set-node-status! successor 'open)
                     (set-node-parent! successor n)
                     (set-node-value! successor (value (node-state successor) (node-cost successor)))
                     (set! new-nodes (append new-nodes (list successor))))
                    (else
                     (check-new-path n successor))))
            ;; Rearrange open.
            (case merge-method
              ((prepend)
               (set! open (append new-nodes open)))
              ((append)
               (set! open (append open new-nodes)))
              ((merge)
               (set! open (sort (append open new-nodes)
                                (lambda (n1 n2)
                                  (<= (node-value n1) (node-value n2)))))))
            ;; Loop.
            (loop)))))
    ;; Print the graph statistics.
    (graph-statistics)
    ;; Return the solution.
    solution))
